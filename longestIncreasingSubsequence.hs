{-
A sub-sequence is a sequence that can be generated by deleting zero or more elements from the original sequence while keeping the order. For example, (1,2), (2, 3) and (1, 2, 3) are valid sub-sequences of (1, 2, 3) while (2, 1) is not. A sequence is called increasing if all the elements are strictly increasing. Formally, (S1, S2, ... , SN-1, SN) is said to be increasing if Si < Si+1 ∀ i ∈ [1, N-1]. Given an integer sequence S, your task is to find the length of the longest increasing subsequence of S.
For this problem, you have to write a function which takes an integer array S and returns an integer denoting the length of the longest increasing sub-sequence of S.
 
Constraints:
1 <= N <= 1,000
1 <= Si <= 1,000,000
 
Sample Input #1:
[1 4 3]
 
Sample Output #1:
2
 
Sample Input #1
[1 4 5 2 6]
 
Sample Output #2:
4
 
Sample Input #3:
[2 3 3 5]
 
Sample Output #3:
3
 
Explanations:
The longest increasing sub-sequence is [1, 3]. Hence the answer is 2
The longest increasing sub-sequence is [1, 4, 5, 6]. The length is 4.
We are interested in strictly increasing sub-sequences, so the longest is [2, 3, 5]. The length is 3.
-}

import Data.List

-- this problem is broken on HR
subsequence :: [Int] -> [[Int]]
subsequence a = filter (isIncreasing) $ subsequences a

isIncreasing :: [Int] -> Bool
isIncreasing l =  fst $ foldl agg (True, minBound :: Int) l
  where agg (bool, int) next = (bool && int < next, next)

findLIS s = foldl max 0 $ map length $ subsequence s


